#pragma kernel Init
#pragma kernel Draw
#pragma kernel Main

RWTexture2D<float4> Result;
RWTexture2D<float4> Cells;
Texture2D<float4> CellsBuffer;

Texture2D<float3> Gradient;
SamplerState samplerGradient;

float2 PointerPosition;

#define WHITE float4(1, 1, 1, 1)
#define BLACK float4(0, 0, 0, 1)

float hash12(float2 p)
{
    float3 p3  = frac(float3(p.xyx) * .1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return frac((p3.x + p3.y) * p3.z);
}

float invLerp(float a, float b, float x)
{
    return (x - a)/(b - a);
}

float conv(float x)
{
    return exp(-pow((x - 0.5) / (2 * 0.1), 2));
}

float growth(float x)
{
    return exp(-pow((x - 0.3) / (2 * 0.07), 2)) * 2 - 1;
}

[numthreads(32,32,1)]
void Init(uint3 id : SV_DispatchThreadID)
{
    //Result[id.xy] = hash12(id.xy) > 0.6 ? WHITE : BLACK;
}

[numthreads(32,32,1)]
void Draw(uint3 id : SV_DispatchThreadID)
{
    float dst = distance(id.xy, PointerPosition.xy);
    Cells[id.xy] = dst < 50 && CellsBuffer[id.xy].r == 0 ? float4(hash12(id.xy), 0, 0, 1) : CellsBuffer[id.xy];
}

[numthreads(32,32,1)]
void Main(uint3 id : SV_DispatchThreadID)
{
    float count = 0;
    float total = 0;

    for (int y = -12; y < 13; y++)
    {
        for (int x = -12; x < 13; x++)
        {
            float dst = distance(id.xy, id.xy + int2(x, y));
            float value = CellsBuffer[id.xy + int2(x, y)].r;

            float filter = conv(abs(dst / 12));
            
            if (dst <= 13)
            {
                count += filter;
                total += value * filter;
            }
        }
    }

    total /= count;
    
    float cellValue = CellsBuffer[id.xy].r;
    cellValue += growth(total);
    cellValue = clamp(cellValue, 0.0, 1.0);
    Cells[id.xy] = float4(cellValue, 0, 0, 1);
    
    float3 gradientColor = Gradient.SampleLevel(samplerGradient, float2(cellValue, 0), 0).rgb;
    Result[id.xy] = float4(cellValue == 0 ? 0 : gradientColor, 1);
}
